using DrWatson
@quickactivate "poor-countries-simple-products"

# Activate packages:
using Planner
using DataFrames
using DataFramesMeta
using Chain
using Arrow
using Statistics
using CSV

# OUTLINE:
# I clean electricity use observations in the following way:
# 1. I reduce the inputs-data block (H) to two dataframes: one with the
# amount of electricity generated by the factory and one with the amount of
# electricty purchased and consumed by the factory.
#
# 2. I flag outlier observations in two ways:
# A. If a plant observation reports that it uses more than 110% or less than 90%
# of the electricity it reports generating and purchasing, I set all of its
# electricity variables to missing.
# B. If a plant's implied kWh price (kwh purchased / price paid) is less than 2%
# or more than 5000% of the median price in state-in-year-price I set electricity
# purchased to missing.

H_df = Arrow.Table(datadir("temp", "formatted-blocks", "block-H-all-years.arrow")) |> DataFrame

# Get electricity consumed -----------------------------------------

# Electricity generated (kwh):
# 00-01: sno = 10, code = 99904
# 01-02: sno = 10, code = 99904
# 02-03: sno = 10, code = 99904
# 03-04: sno = 15, code = 99904
# 04-05: sno = 15, code = 99904
# 05-06: sno = 15, code = 99904
# 06-07: sno = 15, code = 99904
# 07-08: sno = 15, code = 99904
# 08-09: sno = 15, code = 99904
# 09-10: sno = 15, code = 99904
# 10-11: sno = 15, code = 9990400
# 11-12: sno = 15, code = 9990400
# 12-13: sno = 15, code = 9990400
# 13-14: sno = 15, code = 9990400
# 14-15: sno = 15, code = 9990400
# 15-16: sno = 15, code = 9990400

electricity_generated_df = @chain H_df begin
    @rsubset(_, :item_code ∈ ["99904", "9990400"] && :sno ∈ [10, 15] && :qty_unit == 28.0)
    @rtransform(_, :electricity_generated_kwh = :qty_consumed)
    @select(_, :year, :factory_id, :electricity_generated_kwh)
end

# Two factories have two electricity generated observations in the same year.
# I remove them.
# NOTE: There are significantly fewer observations in 2012-13. Why?
# (around 9100 instead of ~14000).
electricity_generated_reporting_df = @chain electricity_generated_df begin
    groupby(_, [:factory_id, :year])
    combine(_, nrow => :count)
    @rsubset(_, :count > 1)
end

electricity_generated_df = antijoin(electricity_generated_df,
                                    electricity_generated_reporting_df,
                                    on=[:factory_id, :year])


@chain electricity_generated_df groupby(:year) combine(nrow => :count)

# Electricity purchased and consumed (kwh):
# 00-01: sno = 11, code = 99905
# 01-02: sno = 11, code = 99905
# 02-03: sno = 11, code = 99905
# 03-04: sno = 16, code = 99905
# 04-05: sno = 16, code = 99905
# 05-06: sno = 16, code = 99905
# 06-07: sno = 16, code = 99905
# 07-08: sno = 16, code = 99905
# 08-09: sno = 16, code = 99905
# 09-10: sno = 16, code = 99905
# 10-11: sno = 16, code = 9990500
# 11-12: sno = 16, code = 9990500
# 12-13: sno = 16, code = 9990500
# 13-14: sno = 16, code = 9990500
# 14-15: sno = 16, code = 9990500
# 15-16: sno = 16, code = 9990500

electricity_purchased_df = @chain H_df begin
    @rsubset(_, :item_code ∈ ["99905", "9990500"] && :sno ∈ [11, 16] && :qty_unit == 28.0)
    @rtransform(_, :electricity_purchased_kwh = :qty_consumed)
    @rtransform(_, :electricity_purchased_val = :purchase_val)
    @select(_, :year, :factory_id, :electricity_purchased_kwh, :electricity_purchased_val)
end

# One factory have two electricity generated observations in the same year.
# I remove it.
electricity_purchased_reporting_df = @chain electricity_purchased_df begin
    groupby(_, [:factory_id, :year])
    combine(_, nrow => :count)
    @rsubset(_, :count > 1)
end

electricity_purchased_df = antijoin(electricity_purchased_df,
                                    electricity_purchased_reporting_df,
                                    on=[:factory_id, :year])

# Flag outliers: --------------------------------------------------- #
# If the value per kwh is too high, this is a flag:

electricity_df = outerjoin(electricity_generated_df,
                           electricity_purchased_df,
                           on=[:year, :factory_id])


state_df = Arrow.Table(datadir("processed", "ASI", "state-id.arrow")) |> DataFrame

# Add states to electricity observations:
electricity_df = leftjoin(electricity_df,
                                    @select(state_df, :year, :factory_id, :state),
                                    on=[:year, :factory_id])

# Some observations have faulty factory ids (~100) meaning they can't be matched
# to a state. Drop them:
dropmissing!(electricity_df, :state)

function sometihng!(row)
    # Some observations have electricity purchased, but no value (~40). I set them
    # to missing.
    if ismissing(row.electricity_purchased_val) || ismissing(row.electricity_purchased_kwh)
        return
        end
end

row.electricity_purchased_val > 0 && row.electricity_purchased_kwh == 0 ? true : false

f(x) = x + 1

passmissing(sum)([1, 2, missing, 3])

sum([1, 2, missing, 3])

@chain electricity_df begin
    passmissing(@rtransform)(_, :has_flag = :electricity_purchased_val > 0 && :electricity_purchased_kwh == 0 ? true : false)
end

@rsubset(electricity_purchased_df,
         :electricity_purchased_val > 0,
         :electricity_purchased_kwh == 0)

# Some observations have no electricity purchased, but value (~10300). I set them
# to missing.





# Calculate implied kwh price:
@rtransform!(electricity_purchased_df,
             :kwh_price = :electricity_purchased_val / :electricity_purchased_kwh)


# Calculate median state-year electricity price
stateyear_median_prices = @chain electricity_purchased_df begin
    dropmissing(_, :state)
    groupby(_, [:year, :state])
    @combine(_, :median_kwh_price = median(:kwh_price))
end

# Add median prices to electricity observations and run flag-checks:
electricity_purchased_df = leftjoin(electricity_purchased_df,
                                    stateyear_median_prices,
                                    on = [:year, :state])

@chain electricity_purchased_df begin
    @rtransform(_,
                :perc_of_median_price = :kwh_price / :median_kwh_price * 100)
    @orderby(_, :perc_of_median_price)
end
