using DrWatson
@quickactivate "poor-countries-simple-products"

using CSV
using Arrow
using DataFrames
using DataFramesMeta
using ShiftedArrays
using Statistics

# The purpose of this script is to (1) create a harmonized list of hydro-power plants and (2)
# add plant-designs to all the observations of hydro-power plants. We are interested in
# plant-designs because run-of-river type plants cannot store water for subsequent years
# and are therefor dependent on rainfall for their power output. This makes them useful
# for instrumenting power shortages.

# A challenge is that the CEA does not report the same names for the same power plants across
# different years. They are typically easy to spot (RP Sagar, R.P.Sagar, fx.). However,
# sometimes plants are reported as a group, and sometimes separate (Teesta I, Teesta I and II, fx.)
# This means that when doing the analysis, we have to collapse power plants into their group totals
# (because there is no way to separate the power generated by a single plant in when reporting
# is by the group).
#
# The early years of hydro-power plant observations have been digitzed (transcribed by hand)
# by Allcott et al (2016).
#
# Plant designs come from the Global Energy Observatory (+ manual checking online).
#
# For the early years, Allcott et al (2016) also match the "early-sample" power plant names
# with plant-types. As mentioned, power plants are sometimes reported by group. Allcott et al
# also report "power plant group" for each relevant plant in their sample. This is convenient
# for me, since I can exploit their group- and type variable to match later observerations
# (outside the Allcott et al sample) to their scheme. This reduces the amount of manual checking,
# typing, and grouping that I have to do.

# What does this script do?
# (1) Read and prepare the spreadsheet with plant types supplied in the replication documents
# from Allcott et al.
# (2) Read and prepare the spreadsheet with plant groups supplied in the replication documents
# from Allcott et al.
# (3) Read and prepare the early CEA data on the performance of hydro-power plants supplied
# in the replication documents from Allcott et al.
# (4) Read and prepare the later CEA data on the performance of hydro-power plants.
# (5) Add types and groups to the early CEA data and the late CEA data and join the datasets.
# (6) Collapse observations into "power plant"-group-year observations.
# (7) Save the data to file.

# ================================================================== #
# (1) Prepare plant-type data (from Allcott et al):
# ------------------------------------------------- #
# In this section, I'm mostly reproducing a .do file from the replication
# instructions in the Allcott et al repository.

repdir = datadir("external", "112983-V1", "replication_archive_AER_september_2015", "01.-Data")
# Read Allcott et al's plant type data:
allcott_types = CSV.read(
    joinpath(repdir, "Hydro-Plants", "Global-Observatory", "hydro_plant_types_new.csv"),
    DataFrame
)

# Select variables and fix names:
@select!(allcott_types,
         :station = :Station,
         :state = :State_final,
         :type = :Type_final,
         :xcoord, :ycoord)

# Make all string columns uppercase and strip whitespace:
function fixstringcols(val)
    val = strip(val)
    val = uppercase(val)
    return val
end

allcott_types = @chain allcott_types begin
    @rtransform(_,
             :station = passmissing(fixstringcols)(:station),
             :state = passmissing(fixstringcols)(:state),
             :type = passmissing(fixstringcols)(:type))
end

# Remove any duplicate rows:
unique!(allcott_types)

# Fix some state names:
@rtransform!(allcott_types,
            :state = :state == "UP" ? "UTTAR PRADESH" :
                :state == "HP" ? "HIMACHAL PRADESH" :
                :state == "J&K" ? "JAMMU AND KASHMIR" :
                :state == "MP" ? "MADHYA PRADESH" :
                :state,
             :xcoord= round(:xcoord, digits = 3),
             :ycoord= round(:ycoord, digits = 3))

# Make sure there is only one observation per plant name:
@chain allcott_types begin
    groupby(_, :station)
    combine(_, nrow => :count)
    @assert all(_.count .== 1)
end

# ================================================================== #
# (2) Prepare plant-group data (from Allcott et al):
# -------------------------------------------------- #
allcott_plant_names = CSV.read(
    joinpath(repdir, "Hydro-Plants", "Global-Observatory", "clean_plant_names.csv"),
    DataFrame
)

# Reduce to only the years we're interested in:
#@rsubset!(allcott_plant_names, :year > 1998)

# Select variables:
@select!(allcott_plant_names, :station, :state, :group, :group_type)

# Remove potential duplicate rows from removing variables:
unique!(allcott_plant_names)

# There is a few missing obsersvations (needed to match groups:)

# Make sure there is only one observation per plant name:
@chain allcott_plant_names begin
    groupby(_, [:station, :state])
    combine(_, nrow => :count)
 #   @rsubset(_, :count > 1)
    @assert all(_.count .== 1)
end

# ================================================================== #
# (3) Prepare early CEA data (from Allcott et al):
# ------------------------------------------------ #
# Here I again follow the instructions from the replication documents.

allcott_plants = CSV.read(
    joinpath(repdir, "Hydro-Plants", "Performance", "Performance-of-Hydro-Power-Stations_adjusted.csv"),
    DataFrame
)

# the `drop` variable is an internal flag from the replication docs that the
# handwritten data was either a duplicate or wrong/has been changed.
@rsubset!(allcott_plants, ismissing(:drop))

rename!(allcott_plants,
        "Year" => :year,
        "Station" => :station,
        "Generation Target (MU)" => :generationtargetmu,
        "Actual Generation (MU)" => :actualgenerationmu,
        "Total (MW)" => :totalmw,
        "% Over Target" => :overtarget)

# the `adjusted` variable is similar to the `drop` flag.
@select!(allcott_plants, $(Not([:drop, :adjusted, :overtarget])))

# only keep years we are interested in:
@rsubset!(allcott_plants, :year > 1998)

# Preformat strings:
allcott_plants = @chain allcott_plants begin
    @rtransform(_,
             :station = passmissing(fixstringcols)(:station))
end

# Fix typo: capacity is instead assigned manually:
@rtransform!(allcott_plants, :totalmw = :totalmw == "Koteshwar" ? "200" : :totalmw)

# Fix variable types:
@rtransform!(allcott_plants,
            :actualgenerationmu = parse(Float64, :actualgenerationmu),
            :hydromw_micro = parse(Float64, :totalmw))

# drop duplicate rows:
unique!(allcott_plants)

# Make the "missing"-code into acutally missing values:
@rtransform!(allcott_plants,
             :hydromw_micro = ifelse(ismissing(:hydromw_micro) || :hydromw_micro ∈ [-99999.0, -9999.0],
                                     missing,
                                     :hydromw_micro),
             :actualgenerationmu = ifelse(ismissing(:actualgenerationmu) || :actualgenerationmu ∈ [-99999.0, -9999.0],
                                          missing,
                                          :actualgenerationmu)
             )

# make sure no negative values are left:
@assert all([ismissing(val) || val >= 0 for val in allcott_plants.hydromw_micro])
@assert all([ismissing(val) || val >= 0 for val in allcott_plants.actualgenerationmu])

# a few plants have been entered twice, but with a typo so unique! doesnt remove them.
@rsubset!(allcott_plants, !(:station == "BAGLIHAR" && :year == 2008 && :generationtargetmu == "100"))
@rsubset!(allcott_plants, !(:station == "GHATGHAR PSS" && :year == 2008 && :generationtargetmu == "10"))
@rsubset!(allcott_plants, !(:station == "KUTTIADI EXT." && :year == 1999 && :generationtargetmu == "30"))
@rsubset!(allcott_plants, !(:station == "N.J. SAGAR RBC" && :year == 2011 && :generationtargetmu == "15"))

# Make sure there is only one observation per plant name in each year:
@chain allcott_plants begin
    groupby(_, [:year, :station])
    combine(_, nrow => :count)
    @assert all(_.count .== 1)
end

# ================================================================== #
# (4) Prepare late CEA data:
# -------------------------- #
# CEA files are separated by year:
cea_paths = readdir(
    datadir("external", "hydro-power", "generation-performance-of-h-e-stations",
            "from-cea", "csv", "tidy"),
    join=true
)

cea_plants = @chain cea_paths[occursin.(".csv", cea_paths)] begin
    CSV.read.(_, DataFrame)
    reduce(vcat, _, cols=:union)
end

# Pre-format the station-names
@rtransform!(cea_plants, :station = uppercase(strip(:station)))

# `station_name_dict` is a dictionary where keys are the name of a power
# plant in the late CEA data (the one I digitized) and the values are the
# the name in the spreadsheet with plant types prepared by Allcott et al.
# We can use this dictionary to create a "joining-variable" between the two
# data sources.
include(scriptsdir("hydro-power-scripts", "station-name-dict.jl"))
@rtransform!(cea_plants,
            :common_station_name = haskey(station_name_dict, :station) ?
                station_name_dict[:station] :
                :station)

# Drop plants that have never produced any power.
# NOTE: Is this necessary? Check capacity-deviations after collapse.
plants_that_have_never_produced = @chain cea_plants begin
    @rtransform :achieved_mu = ismissing(:achieved_mu) ? 0 : :achieved_mu
    groupby(_, :common_station_name)
    @combine(_, :total_achieved = sum(:achieved_mu))
    @rsubset(_, :total_achieved == 0)
end

cea_plants = antijoin(cea_plants, plants_that_have_never_produced, on=:common_station_name)

# ================================================================== #
# (5) Add types and groups to the CEA data and join datasets:
# ----------------------------------------------------------- #
# This section adds plant design type and geolocation (lattitude+longitude)
# to observations of hydro plants. I also add a "group" variable to signify
# what power plant complex or "group" is in. The variable is missing if it
# is not relevant. Groups are necessary because some plants are sometimes
# reported together and sometimes reported apart.

# Add types to both datasets:
cea_types = CSV.read(
    datadir("external", "hydro-power", "generation-performance-of-h-e-stations",
            "from-cea", "missing-plant-types.csv"),
    DataFrame
)
cea_groups = CSV.read(
    datadir("external", "hydro-power", "generation-performance-of-h-e-stations",
            "from-cea", "missing-plant-groups.csv"),
    DataFrame
)

# NOTE: not all of the later CEA plants are matched in the Allcott et al data.
# I therefor collect states and hydro types for the few that is not matched and add them.
cea_plants_w_matches = semijoin(cea_plants, allcott_types, on=[:common_station_name => :station])
cea_plants_wo_matches = antijoin(cea_plants, allcott_types, on=[:common_station_name => :station])

cea_plants_w_matches = leftjoin(cea_plants_w_matches, allcott_types, on=[:common_station_name => :station])
cea_plants_wo_matches = leftjoin(cea_plants_wo_matches, cea_types, on=[:common_station_name => :station])

cea_plants = vcat(cea_plants_w_matches, cea_plants_wo_matches, cols=:union)

allcott_plants = leftjoin(allcott_plants, allcott_types, on=:station)

# Now that states are added to the power plants, we drop a few rows (~1)
@rsubset!(allcott_plants, :state ∉ ["DROP", "BHUTAN", "UNK"])

# Add groups to both datasets:
allcott_plants = leftjoin(allcott_plants, allcott_plant_names, on=[:station, :state])
cea_plants = leftjoin(cea_plants, cea_groups, on=[:station, :state])

# Prepare the datasets before joining:
allcott_plants =
    @chain allcott_plants begin
    rename(_,
           :hydromw_micro => :installed_capacity_mw,
           :generationtargetmu => :target_mu,
           :actualgenerationmu => :achieved_mu)
    @transform(_, :common_station_name = :station)
    @select(_, :station, :common_station_name, :year, :state, :installed_capacity_mw,
            :achieved_mu, :target_mu, :type, :group, :group_type, :xcoord, :ycoord)
end

cea_plants = @select(cea_plants, :station, :common_station_name, :year, :state, :installed_capacity_mw,
                :achieved_mu, :target_mu, :type, :group, :group_type, :xcoord, :ycoord)

# Join the datasets:
hydro_plants = vcat(allcott_plants, cea_plants)

# Write to file. This file is mostly for inspection before collapsing observations.
CSV.write(
    datadir("processed", "power-data", "hydro-power-plants", "hydro-plant-performance-pre-collapse.csv"),
    hydro_plants
)

# ================================================================== #
# (6) TODO Collapse observations into "power plant"-groups:
# -------------------------------------------------------- #
# This section first performs some cleaning of the data as well
# as mitigates some missing data in the original records from the CEA
# (like missing capacity installed). Then each "unit" is collapsed into
# one observation per year.
# A. Mitigate missing capacity
# B. Collapse observations


# A ---------------------------------------------------------------- #
# For some reason, the CEA does not always report the installed capacity. If there is
# capacity, but it is not reported (i.e. it has value = missing) the capacity will
# fluctuate from year to year. This affects the capacity factor I used in my instrument.
# While variation is perfectly acceptable if it is observed, "missing" could be oversights by
# the person recording the entries in the original data, and is not acceptable.
#
# To mitigate this, I go through each observation that has missing capacity and check if the
# same power plant had capacity reported the year before or after.

# A) I proceed in the following way:
# If a plant has `missing` for capacity but has had capacity observed in a previous year,
# I drag the capacity up to the missing year.
#
# B) If a plant does not have capacity observed in a previous year, but does have capacity
# observed in subsequent years, I pull the capacity back IF the plant has had power output (achieved_mu)
# in the current or previous years. This is to avoid adding capacity before the plant was operational.

# I first get a list of each plant-year observations that have a capacity observed previously
rows = []
for row in eachrow(hydro_plants)
    # This is quite a long piece of code, and it doesn't really fix that many observerations.
    # Nevertheless:
    # First, I check if the capacity is missing for the given observation, if capacity have been
    # observed in previous observations of the same station, if capacity has been observed in
    # subsequent observations, and if output has been observed in the current or previous
    # observations.
    #
    # If capacity has previously been observed, I assign the closes previous observation
    # of capacity to the current value.
    #
    # If capacity has not been previously observed, but output has been observed previously
    # or in the current observation AND capacity has been observed in subsequent observations,
    # I assign capacity from the closest observation in the future.

    # is capacity missing - i.e. do we even need to deal with it?
    capacity_missing = ismissing(row.installed_capacity_mw)

    # has capacity been observed before?
    stations_w_prev_cap_obs = @rsubset(hydro_plants,
                                       :common_station_name == row.common_station_name,
                                       :year < row.year,
                                       !ismissing(:installed_capacity_mw))

    stations_w_subs_cap_obs = @rsubset(hydro_plants,
                                       :common_station_name == row.common_station_name,
                                       :year > row.year,
                                       !ismissing(:installed_capacity_mw))

    stations_w_current_or_prev_output_obs = @rsubset(hydro_plants,
                                                     :common_station_name == row.common_station_name,
                                                     :year <= row.year,
                                                     !ismissing(:achieved_mu),
                                                     :achieved_mu > 0)

    stations_w_future_output_obs = @rsubset(hydro_plants,
                                            :common_station_name == row.common_station_name,
                                            :year > row.year,
                                            !ismissing(:achieved_mu),
                                            :achieved_mu > 0)

    has_prev_capacity_been_observed = size(stations_w_prev_cap_obs)[1] > 0
    has_subs_capacity_been_observed = size(stations_w_subs_cap_obs)[1] > 0
    has_achieved_been_observed = size(stations_w_current_or_prev_output_obs)[1] > 0
    has_achieved_been_observed_in_future = size(stations_w_future_output_obs)[1] > 0

    # If capacity is missing AND capacity has been observed, set capacity to the closest
    # previous observation:
    if capacity_missing && has_prev_capacity_been_observed
        # Grab the closest observation in the past:
        new_cap = @subset(stations_w_prev_cap_obs,
                          :year .== maximum(:year)).installed_capacity_mw |> only
        row.installed_capacity_mw = new_cap
    elseif capacity_missing && has_achieved_been_observed && has_subs_capacity_been_observed && has_achieved_been_observed_in_future
        # Grab the closest observation in the future:
        new_cap = @chain hydro_plants begin
            @rsubset(_, :year > row.year,# only use "future years"
                     :common_station_name == row.common_station_name,
                     !ismissing(:achieved_mu),
                     :achieved_mu > 0,
                     !ismissing(:installed_capacity_mw))
            # use the closest year that has capacity and achieved recorded
            @subset(_, :year .== minimum(:year))
            # grab the capacity
            _.installed_capacity_mw
        end
        row.installed_capacity_mw = length(new_cap) > 0 ? only(new_cap) : missing
    end
    push!(rows, row)
end
# Recollect datarows into original frame, now with a few less missing installed capacity observations
hydro_plants = DataFrame(reduce(vcat, rows)) |> unique

# I can now drop all observations that have missing or 0 capacity and missing or 0 achieved.
# They won't provide any value in the collapsing.
hydro_plants = @chain hydro_plants begin
    @rtransform(_,
               :capacity_null = ismissing(:installed_capacity_mw) || :installed_capacity_mw == 0,
                :achieved_null = ismissing(:achieved_mu) || :achieved_mu == 0)
    @rsubset(_, :capacity_null == false && :achieved_null == false)
    @select(_, $(Not([:capacity_null, :achieved_null])))
end

# B ---------------------------------------------------------------- #
# If there is a group/complex value, set the station to the group name. This is used to collapse
# into groups instead of stations later.
@rtransform!(hydro_plants,
            :unit = !ismissing(:group) ? :group : :common_station_name,
            :unit_type = !ismissing(:group_type) ? :group_type : :type)

# There are also some typos:
@rtransform!(hydro_plants, :state = :unit == "JALDHAKA, MASSANJORE AND RAMMAM COMPLEX" ? "WEST BENGAL" : :state)
@rtransform!(hydro_plants, :state = :unit == "MOHAMADPUR, PATHRARI AND NIRGAJANI COMPLEX" ? "UTTARAKHAND" : :state)

# Check if some units only have missing actual generation:
@chain hydro_plants begin
    groupby(:common_station_name)
    @combine(_, :non_missing = sum(:achieved_mu .> 0))
    @assert all(_.non_missing .> 0)
end

# Make it so all units have the xcoord, ycoord of the largest subplant
station_geo_locations = @chain hydro_plants begin
    @rtransform(_,
                :xcoord = round(:xcoord, digits=2),
                :ycoord = round(:ycoord, digits=2))
    groupby(_, :unit)
    @subset(_, :installed_capacity_mw .== maximum(:installed_capacity_mw))
    @select(_, :unit, :final_xcoord = :xcoord, :final_ycoord = :ycoord)
    unique(_)
end

# One complex has more than 1 unique X-coordinate. They are very close, so I fix it manually:
# (NOTE: it is the difference between being on the left and right bank)
@rtransform!(station_geo_locations, :final_xcoord = :unit == "SRISAILAM COMPLEX" ? 78.91 : :final_xcoord)

# Add unified coordinates to plants table:
hydro_plants = @chain hydro_plants begin
    leftjoin(_, station_geo_locations, on=[:unit])
    @select(_, $(Not([:xcoord, :ycoord])))
end


# Check that there is only one unique coordinate per unit now:
@chain hydro_plants begin
    groupby(_, :unit)
    @combine(_,
             :nx = length(unique(:final_xcoord)),
             :ny = length(unique(:final_ycoord)))
    @assert all(_.nx .== 1) && all(_.ny .== 1)
end

# Add run-of-river dummy:
# Preformat strings:
hydro_plants.unit_type = uppercase.(strip.(hydro_plants.unit_type))

run_of_river_designs = uppercase.(["barrage with run-of-river generation",
                                   "run-of-river",
                                   "dam with run-of-river generation"])

dam_designs = uppercase.(["dam on a canal",
                          "dam on a lake",
                          "dam on river with reservoir",
                          "dam"])

@rtransform!(hydro_plants,
            :run_of_river_design = :unit_type ∈ run_of_river_designs,
            :dam_design = :unit_type ∈ run_of_river_designs,
            :other_design = :unit_type ∉ vcat(run_of_river_designs, dam_designs))

# Check that there all run-of-river dummy values are the same for each power unit:
@chain hydro_plants begin
    groupby(_, :unit)
    @combine(_, :n_designs = length(unique(:run_of_river_design)))
 #   @combine(_, :n_designs = length(unique(:dam_design)))
    @assert all(_.n_designs .== 1)
end

# Fix state names so it matches the scheme used in ASI:
state_df = Arrow.Table(datadir("processed", "ASI", "state-id.arrow")) |> DataFrame
states = state_df.state |> unique

@rtransform!(hydro_plants,
            :state = :state == "JAMMU AND KASHMIR" ? "JAMMU & KASHMIR" :
                :state == "ORISSA" ? "ODISHA" :
                :state == "CHHATTISGARH" ? "CHATTISGARH" :
                :state == "ANDAMAN AND NICOBAR ISLANDS" ? "ANDAMAN & NICOBAR" :
                :state)

# Check that every observation has a matching state:
@assert all(in.(hydro_plants.state, Ref(uppercase.(states))))

# TODO: Check what replication docs do.
# TODO: Collapse into unit-observations (doubles as a check of uniqueness:)
@chain hydro_plants groupby(:unit) @combine(:nx = length(unique(:final_xcoord))) @rsubset(:nx .> 1)

hydro_plants_collapsed = @chain hydro_plants begin
    groupby(_, [:unit, :year],)
    @combine(_,
             :installed_capacity_mw = sum(skipmissing(:installed_capacity_mw)),
             :achieved_mu = sum(skipmissing(:achieved_mu)),
             :state = unique(:state) |> only,
             :unit_type = unique(:unit_type) |> only,
             :final_xcoord = unique(:final_xcoord) |> only,
              :final_ycoord = unique(:final_ycoord) |> only,
              :run_of_river_design = unique(:run_of_river_design) |> only,
              :dam_design = unique(:dam_design) |> only,
              :other_design = unique(:other_design) |> only
             )
end
# TODO: Check if all station-year combinations have all the years between minimum and maximum year.

# ================================================================== #
# (7) TODO Save final data to file:
# --------------------------------- #

# ================================================================= #
# Check if allcott_types station names are in the newer CEA data:
# --------------------------------------


function check(cea_station_name)
    allcott_types.station[occursin.(cea_station_name, allcott_types.station)]
end

function fix_names(name)
    if haskey(station_name_dict, name)
        name = station_name_dict[name]
        return name
    else
        return name
    end
end

# NOTE: The station names not matched after using the dictionary have all become operational
# after 2011, and therefor CANNOT be matched to earlier data.

check("N.J")
stations = fix_names.(cea_stations.station |> unique) |> unique |> sort
not_in = [station for station in stations if station ∉ allcott_types.station]
